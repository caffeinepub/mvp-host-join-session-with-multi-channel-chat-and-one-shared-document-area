{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "RPG Collaboration — Fix initialization hang and improve startup recovery",
  "requirements": [
    {
      "id": "REQ-1",
      "summary": "Make actor initialization timeout fire reliably and transition the UI away from the infinite “Initializing…” screen, with a non-reloading retry path.",
      "acceptanceCriteria": [
        "If backend actor creation/access-control initialization does not complete within 30 seconds, the app stops showing the infinite loading screen and shows the existing InitializationFailureScreen with a timeout error message.",
        "The timeout mechanism does not reset continuously during renders while actor initialization is still in progress (i.e., the 30-second timer actually fires).",
        "Clicking “Retry Initialization” retries actor initialization without requiring a full page reload loop that immediately returns to the same stuck state."
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useActorWithErrorHandling.ts",
          "operation": "modify",
          "description": "Refactor the hook to own the actor initialization lifecycle (instead of relying on render-driven timer state), implement a single 30-second timeout that cannot be continuously reset by re-renders, and expose a retry function that re-attempts actor initialization without using window.location.reload()."
        },
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Ensure the app switches from the “Initializing…” screen to InitializationFailureScreen when useActorWithErrorHandling reports a timeout error, and wire “Retry Initialization” to the hook’s non-reloading retry function."
        }
      ]
    },
    {
      "id": "REQ-2",
      "summary": "Surface actor creation/initialization failures immediately (not only via timeout) by capturing rejected promises and showing InitializationFailureScreen with the underlying error.",
      "acceptanceCriteria": [
        "When the actor creation query fails quickly (e.g., rejected promise, agent error, canister trap), the error is captured and InitializationFailureScreen is shown with the error message.",
        "The app does not remain on “Initializing…” indefinitely when an actor initialization error occurs before the timeout."
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useActorWithErrorHandling.ts",
          "operation": "modify",
          "description": "Add immediate error capture for actor creation and any access-control initialization step so that failures (rejections/exceptions) set the hook error state and stop the loading UI without waiting for the timeout."
        },
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Confirm the app’s top-level render path prioritizes showing InitializationFailureScreen when the actor initialization hook reports an error, preventing indefinite “Initializing…” when initialization fails early."
        }
      ]
    },
    {
      "id": "REQ-3",
      "summary": "Avoid indefinite access-control initialization by safely handling missing/empty admin token on the frontend and only attempting secret-based initialization when a token is present.",
      "acceptanceCriteria": [
        "If no `caffeineAdminToken` secret is present (via the existing getSecretParameter flow), actor initialization does not call secret-based access-control initialization with an empty string.",
        "The app successfully reaches the login screen or main app flow (depending on authentication state) on a fresh load with no admin token present."
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useActorWithErrorHandling.ts",
          "operation": "modify",
          "description": "During actor initialization, read `caffeineAdminToken` via the existing getSecretParameter flow and conditionally perform secret-based access-control initialization only when a non-empty token is present, preventing empty-string secret initialization from blocking startup."
        },
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Validate the startup gating conditions so that, when no admin token is present and the user is unauthenticated, the UI can proceed to the existing login prompt (or the main flow when authenticated) rather than remaining stuck on “Initializing…”."
        }
      ]
    },
    {
      "id": "REQ-4",
      "summary": "Provide a minimal, actionable recovery path in InitializationFailureScreen with English-only messaging and a working “Clear Local Data & Retry” flow that re-attempts initialization without leaving an infinite spinner.",
      "acceptanceCriteria": [
        "InitializationFailureScreen continues to display an English error summary plus the underlying error message (e.g., timeout vs. initialization failure).",
        "“Clear Local Data & Retry” clears local/session storage using the existing clearLocalAppData path and then re-attempts initialization successfully when the underlying issue is stale client state.",
        "No infinite spinner remains after a failure; the user always ends up on either InitializationFailureScreen, the login prompt, profile setup, lobby, or session UI."
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/app/InitializationFailureScreen.tsx",
          "operation": "modify",
          "description": "Tighten the recovery UX copy (English only) to clearly distinguish timeout vs. initialization failure using the provided error message, and ensure the screen remains the stable post-failure state (no spinner) while offering the two recovery actions."
        },
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Update “Clear Local Data & Retry” wiring to call the existing clearLocalAppData path and then re-attempt initialization via the hook’s retry function (and react-query cache reset as needed), without using a forced full page reload, so users can recover from stale client state."
        },
        {
          "path": "frontend/src/lib/clearLocalAppData.ts",
          "operation": "modify",
          "description": "Confirm local/session storage clearing is robust for startup recovery (no throws, safe in all browsers) and supports the initialization recovery flow used by InitializationFailureScreen and AppErrorBoundary."
        }
      ]
    }
  ]
}